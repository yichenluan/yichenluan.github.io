---
title: 构造过程抽象
layout: post
tags:
  - Program
---



SICP 选用 Lisp 作为讨论程序设计的基础，考虑到的是 Lisp 的一个重要特征：计算过程的 Lisp 描述（即过程）本身又可以作为 Lisp 的数据来表示和操作。

## 一、程序设计的基本元素

每种强有力的语言都提供了三种机制：

1. 基本表达形式：用于表示语言所关心的最简单的个体。
2. 组合的方法：通过它们可以从较简单的东西出发构造出复合的元素。
3. 抽象的方法：通过它们可以为复合对象命名，并将它们作为单元去操作。

#### 1.1 表达式

``` lisp
(+ 21 35 12 7)
```

这种形式称为前缀表示



#### 1.2 命名和环境

``` lisp
(define size 2)
```

define 是我们所用的语言里最简单的抽象方法。



#### 1.3 过程应用的代换模型

- 正则序求值：完全展开而后规约
- 应用序求值：先求值参数而后应用



#### 1.4 牛顿法求平方根

``` lisp
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))
```

#### 1.5 练习1.6

[习题解答](http://sicp.readthedocs.org/en/latest/chp1/6.html)



### 二、过程与它们所产生的计算

#### 2.1 练习1.11

迭代计算过程:

``` lisp
(define (fib n)
  (fib-iter 2 1 0 n))

(define (fib-iter a b c n)
  (if (< n 3)
      a
      (fib-iter (+ a
                   (* 2 b)
                   (* 3 c))
                a
                b
                (- n 1))))
```

#### 2.2 练习1.12

``` lisp
(define (Paska line row)
  (cond ((> row line) 0)
        ((= row 1) 1)
        ((= row line) 1)
        (else (+ (Paska (- line 1)
                        (- row 1))
                 (Paska (- line 1)
                        row)))))
  
```

#### 2.3 练习1.16

``` lisp
(define (fast-expt b n)
    (expt-iter b n 1))

(define (square b)
  (* b b))

(define (expt-iter b n a)
    (cond ((= n 0)
            a)
          ((even? n)
            (expt-iter (square b)
                       (/ n 2)
                       a))
          ((odd? n)
            (expt-iter b
                       (- n 1)
                       (* b a)))))
```

#### 2.4 练习1.18

``` lisp
(define (multi a b)
    (multi-iter a b 0))

(define (multi-iter a b product)
    (cond ((= b 0)
            product)
          ((even? b)
            (multi-iter (double a)
                        (halve b)
                        product))
          ((odd? b)
            (multi-iter a
                        (- b 1)
                        (+ a product)))))
```

